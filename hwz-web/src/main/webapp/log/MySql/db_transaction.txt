1.据库事务的理解
	基本事务属性:1)传播行为---2)隔离级别---3)只读--- 4)事务超时--- 5)回滚规则
	1)传播行为
		PROPAGATION_REQUIRED:如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。
		PROPAGATION_SUPPORTS: 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。
		PROPAGATION_MANDATORY:如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。
		PROPAGATION_REQUIRED_NEW:总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
		PROPAGATION_NOT_SUPPORTED:总是非事务地执行，并挂起任何存在的事务。
		PROPAGATION_NEVER:总是非事务地执行，如果存在一个活动事务，则抛出异常。
		PROPAGATION_NESTED:
	2)隔离级别
		未提交读（Read uncommitted） 可以读取到其他事务未提交的数据。			（脏读，不可重复读，幻读）
		已提交读（Read committed） 可以读取到其他事务已提交的数据。			（不可重复读，幻读）
		可重复读（Repeatable read）可重复读，对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改	（幻读）
		可串行化（Serializable ） 完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞（无）
		
		隔离级别与数据库锁的关系
		Read uncommitted：任何操作都不会加锁
		Read committed：数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的
		Repeatable read：
		Serializable：这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差
	3)只读
		数据库可以利用事务的只读特性来进行一些特定的优化
	4）事务超时
		为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源
	5)回滚规则
	
	编程式事务:用户在代码中精确定义事务的边界，提供了更加详细的事务管理，在业务代码中编写(侵入性强)
	
	声明式事务:（基于AOP）起到事务管理的作用，有助于用户将操作与事务规则进行解耦，不影响业务代码
	1) 注解形式
	2) tx 标签
2.事务总结，事务与锁的关系，隔离级别
	事务的隔离级别与数据库的锁关系
	http://www.jb51.net/article/75452.htm
	隔离级别实验
	http://xm-king.iteye.com/blog/770721
	事务总结
	http://www.mamicode.com/info-detail-1248286.html
	事务配置
	http://blog.csdn.net/gaoqiao1988/article/details/38922123
	
